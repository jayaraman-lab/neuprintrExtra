#' Builds a data frame of pathways between 2 collections of types
#' \code{get_type2typePath} returns a pathway table, whereas \code{get_type2typePath_raw} returns a list of connection tables
#' @param type.from  a metadata data.frame for a set of neurons (typically generated by a search or a getTypesTable call) to start from
#' @param type.to  a metadata data.frame for a set of neurons (typically generated by a search or a getTypesTable call) to arrive to
#' @param by.roi return results by ROI or just global weights?
#' @param ROI which ROIs to consider. Can be a vector of ROI names, a list of vectors of ROI names, or NULL. If NULL (the default), consider all ROIs. 
#' If a character vector, restrict to those ROIs. If a list, each element of the list will be ROI that will be combined together 
#' (and named as the element name in the list) using combineRois
#' @param n_step an integer or vector of integers. If a vector paths of all those lenghts will be listed.
#' @param renaming a renaming function to use (by default \code{cxRetyping})
#' @param stat which stat to use for pathway weights. Can be a vector. If NULL (the default), all the available meaningful stats are used: 
#' (\code{"weightRelative","outputContribution","knownWeightRelative","knownOutputContribution","knownOutputContribution_perType","knownWROutputContribution_perType","knownWeightRelative_perType"})
#' @param excludeLoops Logical, whether to exclude paths containing duplicates (TRUE by default)
#' @param addContraPaths Experimental: simulate the opposite side of the brain assuming symetry. The new ROI will be called roi_contra. Only ROIs containing "(R)" 
#' in their name will be considered
#' @param thresholdPerROI Optional filtering of the connection tables to limit to types containing at least \code{thresholdPerROI} synapses of the right 
#' polarity in the ROI considered
#' @param computeKnownRatio Compute total relative metrics at each step (this is slow)
#' @param chunkPath Chunking argument to be passed to the function chaining the connection tables together. Useful for deep pathways. Can either be logical,
#' or an integer specifying the number of connections in the starting table to process at once.
#' @param addRecursive Whether or not to add the recursive paths (of length greater than \code{n_steps}) present in the connection tables generated.
#' @param ... : to be passed to neuronBag when building the path
#' @details \itemize{
#' \item If n_steps is 3, only paths of length 3 will be listed. To get all paths of length 1 to 3, you need to pass 1:3 to n_steps. 
#' All vectors of integers are possible for n_steps.
#' \item If \code{type.from} or \code{type.to} are left unspecified, all pathways of the specified length to (resp. from) the specified type are listed.
#' Use at your own risk, as this can potentially result in very large objects.
#' }
#' @export
get_type2typePath <- function(type.from=NULL,
                              type.to=NULL,
                              by.roi=TRUE,
                              ROI=NULL,
                              n_steps=2,
                              renaming=NULL,
                              stat=NULL,
                              excludeLoops=TRUE,
                              addContraPaths=FALSE,
                              thresholdPerROI=NULL,
                              computeKnownRatio = FALSE,
                              combineContraPaths=FALSE,
                              chunkPath=FALSE,
                              addRecursive=FALSE,
                              ...){
  if(is.null(renaming)){renaming <- function(x,postfix="raw",...){
    redefine_types(x,idemtyper,postfix=postfix,...)}
  }
  res <- get_type2typePath_raw(type.from,type.to,by.roi,ROI,n_steps,renaming,addContraPaths,thresholdPerROI,computeKnownRatio,combineContraPaths,...)
  
  if(!(is.null(type.to))) {if(!("databaseType" %in% names(type.to))){
    type.to <- mutate(type.to,databaseType=as.character(type))}
    type.to <- renaming(type.to)}
  res <- tableChain2path(res,n_steps=n_steps,stat=stat,excludeLoops=excludeLoops,type.to=type.to,chunkPath=chunkPath,addRecursive = addRecursive)
  res
}

#' 
#' @describeIn get_type2typePath Returns the list of connection tables (can be chained with tableChain2path)
#' @export
get_type2typePath_raw <- function(type.from=NULL,
                              type.to=NULL,
                              by.roi=TRUE,
                              ROI=NULL,
                              n_steps=2,
                              renaming=NULL,
                              addContraPaths=FALSE,
                              thresholdPerROI=NULL,
                              computeKnownRatio = FALSE,
                              combineContraPaths=FALSE,
                              ...){
  stopifnot("At least one of type.from or type.to must be specified"=!is.null(type.from) | !is.null(type.to))
  if (addContraPaths & is.null(ROI)){stop("You should specify a set of (preferably right side) ROIs for `addContraPaths` to make sense.")}
  if(is.null(renaming)){renaming <- function(x,postfix="raw",...){
    redefine_types(x,idemtyper,postfix=postfix,...)}
  }
  
  res <- vector("list",max(n_steps))
  
  if (is.list(ROI)){
    ROIraw <- unlist(ROI,use.names = FALSE)
    }else{ROIraw <- ROI}
  
  if (addContraPaths & is.list(ROI)){
    if (combineContraPaths){
      ROI <- lapply(ROI,function(r) c(r,paste0(r,"_contra")))
      }else{
       ROI_contra <- lapply(ROI,function(r) paste0(r,"_contra"))
       names(ROI_contra) <- paste0(names(ROI),"_contra")
       ROI <- c(ROI,ROI_contra)
      }
  }
  
  midP <- ceiling(max(n_steps)/2)
  downHalf <- seq(1,midP,length.out = midP)
  upHalf <- seq(midP+1,max(n_steps),length.out = max(n_steps)-midP)
  
  if(is.null(type.to)){
    downHalf <- 1:max(n_steps)
    upHalf <- integer(0)
  }
  if(is.null(type.from)){
    downHalf <- integer(0)
    upHalf <- 1:max(n_steps)
  }
  
  knownConnections <- getTypeToTypeTable(getConnectionTable(character(0),"PRE"))
  knownUnknowns <- getMeta(character(0)) %>% mutate(databaseType=NA_character_) 
  type.from_toAdd <- getMeta(character(0))
  
  for (n in downHalf){
    bag <- neuronBag(type.from,slctROI=ROIraw,by.roi=by.roi,omitInputs=TRUE,computeKnownRatio=computeKnownRatio,renaming=renaming,addContra=addContraPaths,...)  
    if (is.list(ROI)){
      bag_list <- lapply(names(ROI),function(r) {combineRois(bag,ROI[[r]],r)})
      bag <- do.call(c,bag_list)
    }
    
    if(!is.null(thresholdPerROI)){bag$outputs <- filter(bag$outputs,(totalROIweight*n_targets/n_type)>thresholdPerROI & totalPreROIweight>thresholdPerROI)}
    
    resLoc <- bag$outputs
    res[[n]] <- distinct(rbind(resLoc,filter(knownConnections,type.from %in% type.from_toAdd$type)))
    
    outRef <- renaming(getTypesTable(unique(res[[n]]$databaseType.to)) %>% mutate(databaseType = type)) %>% filter(type %in% res[[n]]$type.to)
    unknowns <- retype.na_meta(getMeta(unique(bag$outputs_raw$to[!(bag$outputs_raw$to %in% outRef$bodyid)])))
    knownUnknowns <- distinct(rbind(unknowns,knownUnknowns))
    outRef <- distinct(filter(rbind(outRef,unknowns,knownUnknowns),type %in% res[[n]]$type.to))
    
    knownConnections <- distinct(rbind(knownConnections,resLoc))
    type.from_toAdd <- filter(outRef,type %in% unique(knownConnections$type.from))
    type.from <- filter(outRef,!(type %in% unique(knownConnections$type.from)))
  }
  
  knownConnectionsIn <- getTypeToTypeTable(getConnectionTable(NULL,"PRE"))
  type.to_toAdd <- getMeta(character(0)) %>% mutate(databaseType=NA_character_) 
  for (n in rev(upHalf)){
    bag <- neuronBag(type.to,slctROI=ROIraw,by.roi=by.roi,omitOutputs=TRUE,computeKnownRatio=computeKnownRatio,renaming=renaming,addContra=addContraPaths,...)   
    if (is.list(ROI)){
      bag_list <- lapply(names(ROI),function(r) {combineRois(bag,ROI[[r]],r)})
      bag <- do.call(c,bag_list)
    }

    if(!is.null(thresholdPerROI)){bag$inputs <- filter(bag$inputs,totalROIweight>thresholdPerROI & totalPreROIweight>thresholdPerROI)}
    
    resLoc <- bag$inputs
    
    res[[n]] <- rbind(resLoc,filter(knownConnectionsIn,type.to %in% type.to_toAdd$type))
    
    knownConnectionsIn <- distinct(rbind(knownConnectionsIn,resLoc))
    
    type.to <- renaming(getTypesTable(unique(res[[n]]$databaseType.from)) %>% mutate(databaseType=type)) %>% filter(type %in% res[[n]]$type.from)
    unknowns <- retype.na_meta(getMeta(unique(bag$inputs_raw$from[!(bag$inputs_raw$from %in% type.to$bodyid)]))) %>% mutate(databaseType=NA_character_) 
    knownUnknowns <- distinct(rbind(unknowns,knownUnknowns))
    type.to <- distinct(filter(rbind(type.to,unknowns,knownUnknowns),type %in% res[[n]]$type.from))
    
    type.to_toAdd <- filter(type.to,type %in% unique(knownConnectionsIn$type.to))
    type.to <- filter(type.to,!(type %in% unique(knownConnectionsIn$type.to)))
    
  }
  
  res
}

#' Multiply 2 connection tables or a pathway table and a connection table and return a type to type pathway table
#' @param inputTable  a type to type connection table, or a pathway table as returned by this function
#' @param outputTable a type to type connection table
#' @param stat which stat to use for pathway weights. Can be a vector. If NULL (the default), all the available meaningful stats are used: 
#' (\code{"weightRelative","outputContribution","knownWeightRelative","knownOutputContribution","knownOutputContribution_perType","knownWROutputContribution_perType","knownWeightRelative_perType"})
#' @param n a number to label the stage in processing 
#' @param excludeIntermediate a character vectors of types that should NOT be intermediate links
#' @return a table with a stat_pathway extra column, and type and roi columns labeled with n or n+1 depending if they are 
#' at the first or second step of the pathway
#' @export
tables2path <- function(inputTable,outputTable,stat=NULL,n=1,excludeIntermediate=NULL){
  if(is.null(stat)) stat <- c("weightRelative","outputContribution","knownWeightRelative","knownOutputContribution","knownOutputContribution_perType","knownWROutputContribution_perType","knownWeightRelative_perType")
 
  if(!is.null(excludeIntermediate)){
    inputTable <- filter(inputTable,!(type.to %in% excludeIntermediate))
    outputTable <- filter(outputTable,!(type.from %in% excludeIntermediate))
  }
  
  inputTable <- filter(inputTable,type.to %in% outputTable$type.from)
  outputTable <- filter(outputTable,type.from %in% inputTable$type.to)
  
  inputTable <-  select(inputTable,starts_with((c("type",
                                                  "databaseType",
                                                  "supertype",
                                                  "roi",paste0(stat,"_")))) | any_of(stat))
  outputTable <-  select(outputTable,starts_with((c("type",
                                                    "databaseType",
                                                    "supertype",
                                                    "roi",paste0(stat,"_")))) | any_of(stat))
  
  
  res <- inner_join(inputTable,outputTable,by=c("type.to"="type.from",
                                                "databaseType.to"="databaseType.from",
                                                "supertype1.to"="supertype1.from",
                                                "supertype2.to"="supertype2.from",
                                                "supertype3.to"="supertype3.from"
                                                ),suffix=c(paste0("_N",n),paste0("_N",n+1)))  %>% 
    rename(!!paste0("type_N",n) := "type.to",
           "type.to"=!!paste0("type.to_N",n+1),
           !!paste0("databaseType_N",n):="databaseType.to",
           "databaseType.to"=!!paste0("databaseType.to_N",n+1),
           !!paste0("supertype1_N",n):="supertype1.to",
           "supertype1.to"=!!paste0("supertype1.to_N",n+1),
           !!paste0("supertype2_N",n):="supertype2.to",
           "supertype2.to"=!!paste0("supertype2.to_N",n+1),
           !!paste0("supertype3_N",n):="supertype3.to",
           "supertype3.to"=!!paste0("supertype3.to_N",n+1)) %>% 
    rename_with(paste0,"_N",n+1,.cols = any_of(stat)) %>%
    rename_with(paste0,"_N",n+1,.cols = any_of("roi"))
  
  for (st in stat[paste0(stat,"_N",n) %in% names(res)]){
    if (!(paste0(st,"_path") %in% names(res))){
      res[[paste0(st,"_path")]] <- res[[paste0(st,"_N",n)]]
    }
    
    res[[paste0(st,"_path")]] <- res[[paste0(st,"_path")]] * res[[paste0(st,"_N",n+1)]]
  }
  res
}



#' Link an arbitrary number of connection tables into a pathway table
#' 
#' @param ... An arbitrary number of connection tables or a list of connection tables. In desired downstream order
#' @inheritParams get_type2typePath
#' @export
tableChain2path <- function(...,n_steps=NULL,stat=NULL,excludeLoops=TRUE,type.to=NULL,excludeIntermediate=NULL,addRecursive=FALSE,chunkPath=FALSE,progress=TRUE){
  if(is.null(stat)) stat <- c("weightRelative","outputContribution","knownWeightRelative","knownOutputContribution","knownOutputContribution_perType","knownWROutputContribution_perType","knownWeightRelative_perType")
  res <- rlang::list2(...)
  
  if (length(res) == 1 && rlang::is_bare_list(res[[1]])) {
    res <- res[[1]]
  }
  
  nP <- nrow(res[[1]])
  if(is.numeric(chunkPath)) {
    chunkPathsize <- chunkPath
  } else {
    # make smaller chunks when progress=T and there aren't so many bodyids
    if (chunkPath ==TRUE)
        chunkPathsize=50L
    else
        chunkPathsize=Inf
  }
  
  if(nP>chunkPathsize) {
    nchunks=ceiling(nP/chunkPathsize)
    chunks=rep(seq_len(nchunks), rep(chunkPathsize, nchunks))[seq_len(nP)]
    res1 <- split(res[[1]], chunks)
    # if we got here and progress is unset then set it
    if(is.null(progress) || is.na(progress)) progress=TRUE
    MYPLY <- if(isTRUE(progress)) pbapply::pblapply else lapply
    d  = do.call(rbind,MYPLY(seq(length(res1)), function(rr) tryCatch(tableChain2path(
      c(res1[rr],res[2:length(res)]),
      n_steps=n_steps,
      stat=stat,
      excludeLoops = excludeLoops,
      type.to=type.to,
      excludeIntermediate=excludeIntermediate,
      chunkPath=FALSE),
      error = function(e) {warning(e); NULL})))
    rownames(d) <- NULL
    return(d)
  }
  
  
  if (is.null(n_steps)){n_steps <- seq(length(res))}
  pathway <- bind_rows(lapply(n_steps,function(nS){
    pathTable <- res[[1]]
    for (i in seq(2,nS,length.out = nS-1)){
      pathTable <- tables2path(pathTable,res[[i]],stat=stat,n=i-1,excludeIntermediate=excludeIntermediate)
    }
    if (!is.null(type.to)){
      pathTable <- pathTable[(pathTable$type.to %in% type.to$type),]
    }
    pathTable[["n_steps"]] <- nS
    if (nS == 1){
      pathTable <- pathTable %>% rename_with(paste0,"_N1",.cols = any_of(stat)) %>%
        rename_with(paste0,"_N1",.cols = any_of("roi")) %>%
        select(starts_with((c("type",
                              "databaseType",
                              "supertype",
                              "roi",paste0(stat,"_N1"),"n_steps"))))
      for (st in stat[paste0(stat,"_N1") %in% names(pathTable)]){
        pathTable[[paste0(st,"_path")]] <- pathTable[[paste0(st,"_N1")]]
      }
    }
    pathTable 
  }))
  
  pathway <- mutate(pathway,pathType="simple")
  if (addRecursive){
    nM <- max(n_steps)
    ## Loop over types found at previous stages
    for(stepN in rev(seq(2,nM,length.out = max(n_steps-1)))){
      toType <- if (stepN==nM) "type.to" else paste0("type_N",stepN)
      ## Loop over which stage those are found
      for(nS in rev(seq(1,stepN-1,length.out = stepN-1))){ 
        toExtend <- filter(pathway,!!sym(toType) %in% !!sym(paste0("type_N",nS)) & n_steps==nM) %>% select(!where(~all(is.na(.x))))
          
        ##Loop forward to build the extented pathways
        for (i in seq(nS+1,nM,length.out = max(n_steps-nS))){
          toExtend <- tables2path(toExtend,res[[i]],stat=stat,n=nM+i-nS-1,excludeIntermediate=excludeIntermediate)
        }
        toExtend <- mutate(toExtend,n_steps=2*nM-nS)
        if (!is.null(type.to)){
          toExtend <- toExtend[(toExtend$type.to %in% type.to$type),]
        }
        pathway <- bind_rows(pathway,toExtend %>% mutate(pathType="recursive"))
      }
    }
  }
  
  pathway <- pathway %>% rowwise() %>% mutate(loop=any(duplicated(c_across(starts_with("type_") |
                                                                     starts_with("type.from")),
                                                          incomparables = c(NA,FALSE))) |
                                        any(duplicated(c_across(starts_with("type_") |
                                                                  starts_with("type.to")),
                                                       incomparables = c(NA,FALSE))
                                        )) %>% ungroup()
  if (excludeLoops) pathway  <- filter(pathway,loop==FALSE)
  pathway %>% select(type.from,
                 starts_with("type_"),
                 type.to,
                 starts_with("roi"),
                 starts_with(paste0(stat,"_N")),
                 starts_with(paste0(stat,"_path")),
                 n_steps,
                 loop,
                 pathType,
                 starts_with("supertype"),
                 starts_with("databaseType"))
}


#' Functions to deal with crossing to the bad side of the brain
addContraSide <- function(connTable){
  rbind(connTable,simulatedContraSide(connTable))
}

addContraSide_meta <- function(metaTable){
  rbind(metaTable,simulatedContraSide_meta(metaTable))
}

simulatedContraSide <- function(connTable){
  ##CHECK IT'S A RAW TABLE
  simulated <- connTable %>% mutate(type.from=lrInvert(type.from),
                                    type.to=lrInvert(type.to),
                                    roi = paste0(roi,"_contra"))
  
  simulated <- filter(simulated,grepl("_L$|_L[1-9]$|_L[1-9]/[1-9]$|_L[1-9]_C[1-9]$|_L[1-9]_C[1-9]_irreg$|_L_C[1-9]_irreg$|_L_small$|_R$|_R[1-9]$|_R[1-9]/[1-9]$|_R[1-9]_C[1-9]$|_R[1-9]_C[1-9]_irreg$|_R_C[1-9]_irreg$|_R_small$",type.from) & 
                                grepl("_L$|_L[1-9]$|_L[1-9]/[1-9]$|_L[1-9]_C[1-9]$|_L[1-9]_C[1-9]_irreg$|_L_C[1-9]_irreg$|_L_small$|_R$|_R[1-9]$|_R[1-9]/[1-9]$|_R[1-9]_C[1-9]$|_R[1-9]_C[1-9]_irreg$|_R_C[1-9]_irreg$|_R_small$",type.to) &
                        (grepl("(R)",roi) | roi=="SAD_contra" | roi=="PRW_contra")) ## Non lateralized neuropiles shouldn't be simulated and neither should types with no L/R info
  
  simulated
  
}

simulatedContraSide_meta <- function(metaTable){
  ##CHECK IT'S A RAW TABLE
  simulated <- metaTable %>% mutate(type=lrInvert(type))
  
  simulated <- filter(simulated,grepl("_L$|_L[1-9]$|_L[1-9]/[1-9]$|_L[1-9]_C[1-9]$|_L[1-9]_C[1-9]_irreg$|_L_C[1-9]_irreg$|_L_small$|_R$|_R[1-9]$|_R[1-9]/[1-9]$|_R[1-9]_C[1-9]$|_R[1-9]_C[1-9]_irreg$|_R_C[1-9]_irreg$|_R_small$|
                                      _L$|_L[1-9]$|_L[1-9]/[1-9]$|_L[1-9]_C[1-9]$|_L[1-9]_C[1-9]_irreg$|_L_C[1-9]_irreg$|_L_small$|_R$|_R[1-9]$|_R[1-9]/[1-9]$|_R[1-9]_C[1-9]$|_R[1-9]_C[1-9]_irreg$|_R_C[1-9]_irreg$|_R_small$",type)) ## Non lateralized neuropiles shouldn't be simulated and neither should types with no L/R info
  
  simulated
  
}

#' @export
lrInvert <- function(typeNames){
  toReplaceLeft <- grepl("_L$|_L[1-9]$|_L[1-9]/[1-9]$|_L[1-9]_C[1-9]$|_L[1-9]_C[1-9]_irreg$|_L_C[1-9]_irreg$|_L_small$|_L\\*$",
                         typeNames)
  toReplaceRight <- grepl("_R$|_R[1-9]$|_R[1-9]/[1-9]$|_R[1-9]_C[1-9]$|_R[1-9]_C[1-9]_irreg$|_R_C[1-9]_irreg$|_R_small$|_R\\*$",
                          typeNames)
  typeNames[toReplaceLeft] <- gsub("_L","_R",typeNames[toReplaceLeft])
  typeNames[toReplaceRight] <- gsub("_R","_L",typeNames[toReplaceRight])
  
  typeNames
}

#' Convert a type-to-type pathway dataframe to a graph dataframe
#' @param pathDf Dataframe generated by get_type2typePath()
#' @return Dataframe specifiying the graph resulting from combining the pathways in pathDF by listing all edges and their weights. Columns are
#' \code{to}, \code{from}, the statistic used as a weight in \code{pathDf} and supertypes to and from columns.
#' @export 
pathDf2graphDf <- function(pathDf){
 
  pathColNames <- colnames(pathDf)
  fromCols <- c("type.from",sort(pathColNames[grep("type_",pathColNames)]))
  toCols <- c(sort(pathColNames[grep("type_",pathColNames)]), "type.to")
  weightBaseName <- sub("_path","",pathColNames[grep("_path",pathColNames)])
  weights <- lapply(weightBaseName,function(wB) sort(pathColNames[grep(paste0(wB,"_N"),pathColNames)]))
  rois <- sort(pathColNames[grep("roi_",pathColNames)])
  
  databaseTypeFrom <- c("databaseType.from",sort(pathColNames[grep("databaseType_",pathColNames)]))
  databaseTypeTo <- c(sort(pathColNames[grep("databaseType_",pathColNames)]),"databaseType.to")
  
  for (i in seq(3)){
    assign( paste0("fromSupertype",i), c(paste0("supertype",i,".from"),sort(pathColNames[grep(paste0("supertype",i,"_N"),pathColNames)])))
    assign( paste0("toSupertype",i),  c(sort(pathColNames[grep(paste0("supertype",i,"_N"),pathColNames)]), paste0("supertype",i,".to")) )
  }
  
  graphDataFrame = data.frame(from = character(),
                              to = character())
  
  for(sN in seq(length(weightBaseName))){
    graphDataFrame[[weightBaseName[sN]]] <-  numeric()
  }
  for (step in seq(length(fromCols)) ){
    toNodes = pathDf[[toCols[step]]]
    toST1 = pathDf[[toSupertype1[step]]]
    toST2 = pathDf[[toSupertype2[step]]]
    toST3 = pathDf[[toSupertype3[step]]]
    toDB <- pathDf[[databaseTypeTo[step]]]
    
    nas = is.na(toNodes)
    toNodes[nas] = pathDf$type.to[nas]
    pathDf$type.to[nas] = NA
    
    toDB[nas] <- pathDf$databaseType.to[nas]
    pathDf$databaseType.to[nas] <- NA
    
    toST1[nas] =pathDf$supertype1.to[nas]
    pathDf$supertype1.to[nas] = NA
    
    toST2[nas] = pathDf$supertype2.to[nas]
    pathDf$supertype2.to[nas] = NA
    
    toST3[nas] = pathDf$supertype3.to[nas]
    pathDf$supertype3.to[nas] = NA
    
    tmp = data.frame(from = pathDf[[fromCols[step]]],
                     to = toNodes,
                     databaseType.from = pathDf[[databaseTypeFrom[step]]],
                     databaseType.to = toDB,
                     supertype1.from = pathDf[[fromSupertype1[step]]],
                     supertype1.to = toST1,
                     supertype2.from = pathDf[[fromSupertype2[step]]],
                     supertype2.to = toST2,
                     supertype3.from = pathDf[[fromSupertype3[step]]],
                     supertype3.to = toST3)
    for(sN in seq(length(weightBaseName))){
      tmp[[weightBaseName[sN]]] <- pathDf[[weights[[sN]][step]]]
    }
    if(length(rois)>0){
      tmp$roi <- pathDf[[rois[step]]]
    }
    graphDataFrame = bind_rows(graphDataFrame,unique(tidyr::drop_na(tmp,to)))
  }
  
  return(graphDataFrame)
}