#' Builds a data frame of pathways between 2 collections of types
#' \code{get_type2typePath} returns a pathway table, whereas \code{get_type2typePath_raw} returns a list of connection tables
#' @param type.from  a metadata data.frame for a set of neurons (typically generated by a search or a getTypesTable call) to start from
#' @param type.to  a metadata data.frame for a set of neurons (typically generated by a search or a getTypesTable call) to arrive to
#' @param by.roi return results by ROI or just global weights?
#' @param ROI which ROIs to consider. Can be a vector of ROI names, a list of vectors of ROI names, or NULL. If NULL (the default), consider all ROIs. 
#' If a character vector, restrict to those ROIs. If a list, each element of the list will be ROI that will be combined together 
#' (and named as the element name in the list) using combineRois
#' @param n_step an integer or vector of integers. If a vector paths of all those lenghts will be listed.
#' @param renaming a renaming function to use (by default \code{cxRetyping})
#' @param stat the stat to consider (by default "weightRelative")
#' @param excludeLoops Logical, whether to exclude paths containing duplicates (TRUE by default)
#' @param addContraPaths Experimental: simulate the opposite side of the brain assuming symetry. The new ROI will be called roi_contra. Only ROIs containing "(R)" 
#' in their name will be considered
#' @param ... : to be passed to neuronBag when building the path
#' @details \itemize{
#' \item If n_steps is 3, only paths of length 3 will be listed. To get all paths of length 1 to 3, you need to pass 1:3 to n_steps. 
#' All vectors of integers are possible for n_steps.
#' \item If \code{type.from} or \code{type.to} are left unspecified, all pathways of the specified length to (resp. from) the specified type are listed.
#' Use at your own risk, as this can potentially result in very large objects.
#' }
#' @export
get_type2typePath <- function(type.from=NULL,
                              type.to=NULL,
                              by.roi=TRUE,
                              ROI=NULL,
                              n_steps=2,
                              renaming=cxRetyping,
                              stat="weightRelative",
                              excludeLoops=TRUE,
                              addContraPaths=FALSE,
                              thresholdPerROI=NULL,
                              ...){
  
  res <- get_type2typePath_raw(type.from,type.to,by.roi,ROI,n_steps,renaming,addContraPaths,thresholdPerROI,...)
  
  res <- tableChain2path(res,n_steps=n_steps,stat=stat,excludeLoops=excludeLoops,type.to=type.to)
  res
}

#' 
#' @describeIn get_type2typePath Returns the list of connection tables (can be chained with tableChain2path)
#' @export
get_type2typePath_raw <- function(type.from=NULL,
                              type.to=NULL,
                              by.roi=TRUE,
                              ROI=NULL,
                              n_steps=2,
                              renaming=cxRetyping,
                              addContraPaths=FALSE,
                              thresholdPerROI=NULL,
                              ...){
  stopifnot("At least one of type.from or type.to must be specified"=!is.null(type.from) | !is.null(type.to))
  if (addContraPaths & is.null(ROI)){stop("You should specify a set of (preferably right side) ROIs for `addContraPaths` to make sense.")}
  
  res <- vector("list",max(n_steps))
  
  if(!is.null(type.from)){
    if (!("databaseType" %in% names(type.from))){type.from <- mutate(type.from,databaseType=type)}
    type.from <- renaming(type.from)
    type.from_loc <- type.from
  }
  
  if(!is.null(type.to)){
    if (!("databaseType" %in% names(type.to))){type.to <- mutate(type.to,databaseType=type)}
    type.to <- renaming(type.to)
    type.to_loc <- type.to
  }
  
  if (is.list(ROI)){ROIraw <- unlist(ROI,use.names = FALSE)}else{ROIraw <- ROI}
  
  midP <- ceiling(max(n_steps)/2)
  downHalf <- seq(1,midP,length.out = midP)
  upHalf <- seq(midP+1,max(n_steps),length.out = max(n_steps)-midP)
  
  if(is.null(type.to)){
    downHalf <- 1:max(n_steps)
    upHalf <- integer(0)
  }
  if(is.null(type.from)){
    downHalf <- integer(0)
    upHalf <- 1:max(n_steps)
  }
  
  knownConnections <- getTypeToTypeTable(getConnectionTable(NULL,"PRE"))
  known_sources <- unique(type.from_loc$type)
  type.from_toAdd <- character(0)
  
  for (n in downHalf){
    bag <- neuronBag(type.from_loc,slctROI=ROIraw,by.roi=by.roi,omitInputs=TRUE,selfRef=TRUE,...)  
    if (is.list(ROI)){
      bag_list <- lapply(names(ROI),function(r) {combineRois(bag,ROI[[r]],r)})
      bag <- do.call(c,bag_list)
    }
    bag <- renaming(bag)
    
    if (addContraPaths){
      resLoc <- addContraSide(bag$outputs)
      outRef <- renaming(getTypesTable(unique(res$databaseType.to)) %>% mutate(databaseType = type)) %>% filter(type %in% res$type.to)
    }else{
      resLoc <- bag$outputs
      outRef <- bag$outputsTableRef
    }
    type.from_loc <- filter(outRef,!(type %in% known_sources))
    
    res[[n]] <- distinct(rbind(resLoc,filter(knownConnections,type.from %in% type.from_toAdd)))
    
    type.from_toAdd <- filter(outRef,(type %in% known_sources))
    knownConnections <- distinct(rbind(knownConnections,bag$outputs))
    known_sources <- unique(knownConnections$type.from)
    
  }
  
  knownConnections <- getTypeToTypeTable(getConnectionTable(NULL,"PRE"))
  known_targets <- unique(type.from_loc$type)
  type.to_toAdd <- character(0)
  for (n in rev(upHalf)){
    bag <- neuronBag(type.to_loc,slctROI=ROIraw,by.roi=by.roi,omitOutputs=TRUE,selfRef=TRUE,...)   
    if (is.list(ROI)){
      bag_list <- lapply(names(ROI),function(r) {combineRois(bag,ROI[[r]],r)})
      bag <- do.call(c,bag_list)
    }
    bag <- renaming(bag)
    
    if (addContraPaths){
      resLoc <- addContraSide(bag$inputs)
    }else{
      resLoc <- bag$inputs
    }
    type.to_loc <- getTypesTable(unique(resLoc$databaseType.from)) %>% mutate(databaseType=type)
    unknowns <- retype.na_meta(neuprint_get_meta(unique(bag$inputs_raw$from[!(bag$inputs_raw$from %in% type.to_loc$bodyid)]))) %>% mutate(databaseType=NA)
    if (length(unknowns != 0)){type.to_loc <- bind_rows(type.to_loc,unknowns)}
    
    type.to_loc <- renaming(type.to_loc)
    type.to_loc <- filter(type.to_loc,type %in% resLoc$type.from)
    
    type.to_loc_old <- type.to_loc
    type.to_loc <- filter(type.to_loc,!(type %in% known_targets))
    res[[n]] <- rbind(resLoc,filter(knownConnections,type.to %in% type.to_toAdd))
    
    type.to_toAdd <- filter(type.to_loc_old,type %in% known_targets)
    knownConnections <- distinct(rbind(knownConnections,resLoc))
    known_targets <- unique(knownConnections$type.to)
  }
  
  res
}

#' Multiply 2 connection tables or a pathway table and a connection table and return a type to type pathway table
#' @param inputTable  a type to type connection table, or a pathway table as returned by this function
#' @param outputTable a type to type connection table
#' @param stat which stat to use for pathway weights
#' @param n a number to label the stage in processing 
#' @return a table with a stat_pathway extra column, and type and roi columns labeled with n or n+1 depending if they are 
#' at the first or second step of the pathway
#' @export
tables2path <- function(inputTable,outputTable,stat="weightRelative",n=1){
  inputTable <-  select(inputTable,starts_with((c("type",
                                        "databaseType",
                                        "supertype",
                                        "roi",paste0(stat,"_")))) | any_of(stat))
  outputTable <-  select(outputTable,starts_with((c("type",
                                        "databaseType",
                                        "supertype",
                                        "roi",paste0(stat,"_")))) | any_of(stat))
 
 
  res <- inner_join(inputTable,outputTable,by=c("type.to"="type.from",
                                                "databaseType.to"="databaseType.from",
                                                "supertype1.to"="supertype1.from",
                                                "supertype2.to"="supertype2.from",
                                                "supertype3.to"="supertype3.from"
                                                ),suffix=c(paste0("_N",n),paste0("_N",n+1)))  %>% 
    rename(!!paste0("type_N",n) := "type.to",
           "type.to"=!!paste0("type.to_N",n+1),
           !!paste0("databaseType_N",n):="databaseType.to",
           "databaseType.to"=!!paste0("databaseType.to_N",n+1),
           !!paste0("supertype1_N",n):="supertype1.to",
           "supertype1.to"=!!paste0("supertype1.to_N",n+1),
           !!paste0("supertype2_N",n):="supertype2.to",
           "supertype2.to"=!!paste0("supertype2.to_N",n+1),
           !!paste0("supertype3_N",n):="supertype3.to",
           "supertype3.to"=!!paste0("supertype3.to_N",n+1)) %>% 
    rename_with(paste0,"_N",n+1,.cols = any_of(stat)) %>%
    rename_with(paste0,"_N",n+1,.cols = any_of("roi"))
  
  if (!(paste0(stat,"_path") %in% names(res))){
    res[[paste0(stat,"_path")]] <- res[[paste0(stat,"_N",n)]]
  }
  
  res[[paste0(stat,"_path")]] <- res[[paste0(stat,"_path")]] * res[[paste0(stat,"_N",n+1)]]
  res
}



#' Link an arbitrary number of connection tables into a pathway table
#' 
#' @param ... An arbitrary number of connection tables or a list of connection tables. In desired downstream order
#' @inheritParams get_type2typePath
#' @export
tableChain2path <- function(...,n_steps=NULL,stat="weightRelative",excludeLoops=TRUE,type.to=NULL){
  res <- rlang::list2(...)
  if (length(res) == 1 && rlang::is_bare_list(res[[1]])) {
    res <- res[[1]]
  }
  if (is.null(n_steps)){n_steps <- seq(length(res))}
  res <- bind_rows(lapply(n_steps,function(nS){
    pathTable <- res[[1]]
    for (i in seq(2,nS,length.out = nS-1)){
      pathTable <- tables2path(pathTable,res[[i]],stat=stat,n=i-1)
    }
    if (!is.null(type.to)){
      pathTable <- pathTable[(pathTable$type.to %in% type.to$type),]
    }
    pathTable[["n_steps"]] <- nS
    if (nS == 1){
      pathTable <- pathTable %>% rename_with(paste0,"_N1",.cols = any_of(stat)) %>%
        rename_with(paste0,"_N1",.cols = any_of("roi")) %>%
        select(starts_with((c("type",
                              "databaseType",
                              "supertype",
                              "roi",paste0(stat,"_N1"),"n_steps"))))
      pathTable[[paste0(stat,"_path")]] <- pathTable[[paste0(stat,"_N1")]]
    }
    pathTable 
  }))
  
  res <- res %>% rowwise() %>% mutate(loop=any(duplicated(c_across(starts_with("type_") |
                                                                     starts_with("type.from")),
                                                          incomparables = c(NA,FALSE))) |
                                        any(duplicated(c_across(starts_with("type_") |
                                                                  starts_with("type.to")),
                                                       incomparables = c(NA,FALSE))
                                        ))
  if (excludeLoops) res  <- filter(res,loop==FALSE)
  res %>% select(type.from,
                 starts_with("type_"),
                 type.to,
                 starts_with("roi"),
                 starts_with(paste0(stat,"_N")),
                 starts_with(paste0(stat,"_path")),
                 n_steps,
                 loop,
                 starts_with("supertype"),
                 starts_with("databaseType"))
}


#' Functions to deal with crossing to the bad side of the brain
addContraSide <- function(connTable){
  rbind(connTable,simulatedContraSide(connTable))
}


simulatedContraSide <- function(connTable){
  simulated <- connTable %>% mutate(type.from=lrInvert(type.from),
                                    type.to=lrInvert(type.to),
                                    roi = paste0(roi,"_contra"))
  
  simulated <- filter(simulated,grepl("(R)",roi) | roi=="SAD_contra" | roi=="PRW_contra") ## Non lateralized neuropiles shouldn't be simulated
  
  simulated
  
}

lrInvert <- function(typeNames){
  toReplaceLeft <- grepl("_L$|_L[1-9]$|_L[1-9]/[1-9]$|_L[1-9]_C[1-9]$|_L[1-9]_C[1-9]_irreg$|_L_C[1-9]_irreg$|_L_small$",
                         typeNames)
  toReplaceRight <- grepl("_R$|_R[1-9]$|_R[1-9]/[1-9]$|_R[1-9]_C[1-9]$|_R[1-9]_C[1-9]_irreg$|_R_C[1-9]_irreg$|_R_small$",
                          typeNames)
  typeNames[toReplaceLeft] <- gsub("_L","_R",typeNames[toReplaceLeft])
  typeNames[toReplaceRight] <- gsub("_R","_L",typeNames[toReplaceRight])
  
  typeNames
}

#' Convert a type-to-type pathway dataframe to a graph dataframe
#' @param pathDf Dataframe generated by get_type2typePath()
#' @return Dataframe specifiying the graph resulting from combining the pathways in pathDF by listing all edges and their weights. Columns are
#' \code{to}, \code{from}, the statistic used as a weight in \code{pathDf} and supertypes to and from columns.
#' @export 
pathDf2graphDf <- function(pathDf){
 
  pathColNames <- colnames(pathDf)
  fromCols <- c("type.from",sort(pathColNames[grep("type_",pathColNames)]))
  toCols <- c(sort(pathColNames[grep("type_",pathColNames)]), "type.to")
  weightBaseName <- sub("_path","",pathColNames[grep("_path",pathColNames)])
  weights <- sort(pathColNames[grep(paste0(weightBaseName,"_N"),pathColNames)])
  rois <- sort(pathColNames[grep("roi_",pathColNames)])
  
  
  for (i in seq(3)){
    assign( paste0("fromSupertype",i), c(paste0("supertype",i,".from"),sort(pathColNames[grep(paste0("supertype",i,"_N"),pathColNames)])))
    assign( paste0("toSupertype",i),  c(sort(pathColNames[grep(paste0("supertype",i,"_N"),pathColNames)]), paste0("supertype",i,".to")) )
  }
  
  graphDataFrame = data.frame(from = character(),
                              to = character())
  
  graphDataFrame[[weightBaseName]] <-  numeric()
  
  for (step in seq(length(fromCols)) ){
    toNodes = pathDf[[toCols[step]]]
    toST1 = pathDf[[toSupertype1[step]]]
    toST2 = pathDf[[toSupertype2[step]]]
    toST3 = pathDf[[toSupertype3[step]]]
    
    nas = is.na(toNodes)
    toNodes[nas] = pathDf$type.to[nas]
    pathDf$type.to[nas] = NA
    
    
    
    toST1[nas] =pathDf$supertype1.to[nas]
    pathDf$supertype1.to[nas] = NA
    
    toST2[nas] = pathDf$supertype2.to[nas]
    pathDf$supertype2.to[nas] = NA
    
    toST3[nas] = pathDf$supertype3.to[nas]
    pathDf$supertype3.to[nas] = NA
    
    tmp = data.frame(from = pathDf[[fromCols[step]]],
                     to = toNodes,
                     supertype1.from = pathDf[[fromSupertype1[step]]],
                     supertype1.to = toST1,
                     supertype2.from = pathDf[[fromSupertype2[step]]],
                     supertype2.to = toST2,
                     supertype3.from = pathDf[[fromSupertype3[step]]],
                     supertype3.to = toST3)
    tmp[[weightBaseName]] <- pathDf[[weights[step]]]
    if(length(rois)>0){
      tmp$roi <- pathDf[[rois[step]]]
    }
    graphDataFrame = bind_rows(graphDataFrame,unique(tidyr::drop_na(tmp)))
  }
  
  return(graphDataFrame)
}