#' Builds a data frame of pathways between 2 collections of types
#' \code{get_type2typePath} returns a pathway table, whereas \code{get_type2typePath_raw} returns a list of connection tables
#' @param type.from  a metadata data.frame for a set of neurons (typically generated by a search or a getTypesTable call) to start from
#' @param type.to  a metadata data.frame for a set of neurons (typically generated by a search or a getTypesTable call) to arrive to
#' @param by.roi return results by ROI or just global weights?
#' @param ROI which ROIs to consider. Can be a vector of ROI names, a list of vectors of ROI names, or NULL. If NULL (the default), consider all ROIs. 
#' If a character vector, restrict to those ROIs. If a list, each element of the list will be ROI that will be combined together 
#' (and named as the element name in the list) using combineRois
#' @param n_step an integer or vector of integers. If a vector paths of all those lenghts will be listed.
#' @param renaming a renaming function to use (by default \code{cxRetyping})
#' @param stat which stat to use for pathway weights. Can be a vector. If NULL (the default), all the available meaningful stats are used: 
#' (\code{"weightRelative","outputContribution","knownWeightRelative","knownOutputContribution","knownOutputContribution_perType","knownWROutputContribution_perType","knownWeightRelative_perType"})
#' @param excludeLoops Logical, whether to exclude paths containing duplicates (TRUE by default)
#' @param addContraPaths Experimental: simulate the opposite side of the brain assuming symetry. The new ROI will be called roi_contra. Only ROIs containing "(R)" 
#' in their name will be considered
#' @param thresholdPerROI Optional filtering of the connection tables to limit to types containing at least \code{thresholdPerROI} synapses of the right 
#' polarity in the ROI considered (forces to run the connection tables with \code{computeKnownRatio} set to TRUE)
#' @param computeKnownRatio Compute total relative metrics at each step (this is slow)
#' @param ... : to be passed to neuronBag when building the path
#' @details \itemize{
#' \item If n_steps is 3, only paths of length 3 will be listed. To get all paths of length 1 to 3, you need to pass 1:3 to n_steps. 
#' All vectors of integers are possible for n_steps.
#' \item If \code{type.from} or \code{type.to} are left unspecified, all pathways of the specified length to (resp. from) the specified type are listed.
#' Use at your own risk, as this can potentially result in very large objects.
#' }
#' @export
get_type2typePath <- function(type.from=NULL,
                              type.to=NULL,
                              by.roi=TRUE,
                              ROI=NULL,
                              n_steps=2,
                              renaming=NULL,
                              stat=NULL,
                              excludeLoops=TRUE,
                              addContraPaths=FALSE,
                              thresholdPerROI=NULL,
                              computeKnownRatio = FALSE,
                              ...){
  if(is.null(renaming)){renaming <- function(x,postfix){identity(x)}}
  res <- get_type2typePath_raw(type.from,type.to,by.roi,ROI,n_steps,renaming,addContraPaths,thresholdPerROI,computeKnownRatio,...)
  
  if(!(is.null(type.to))) type.to <- renaming(type.to)
  res <- tableChain2path(res,n_steps=n_steps,stat=stat,excludeLoops=excludeLoops,type.to=type.to)
  res
}

#' 
#' @describeIn get_type2typePath Returns the list of connection tables (can be chained with tableChain2path)
#' @export
get_type2typePath_raw <- function(type.from=NULL,
                              type.to=NULL,
                              by.roi=TRUE,
                              ROI=NULL,
                              n_steps=2,
                              renaming=NULL,
                              addContraPaths=FALSE,
                              thresholdPerROI=NULL,
                              computeKnownRatio = FALSE,
                              ...){
  stopifnot("At least one of type.from or type.to must be specified"=!is.null(type.from) | !is.null(type.to))
  if (addContraPaths & is.null(ROI)){stop("You should specify a set of (preferably right side) ROIs for `addContraPaths` to make sense.")}
  if(is.null(renaming)){renaming <- function(x,postfix){identity(x)}}
  
  if(!is.null(thresholdPerROI)){computeKnownRatio <- TRUE}
  
  res <- vector("list",max(n_steps))
  
  if (is.list(ROI)){ROIraw <- unlist(ROI,use.names = FALSE)}else{ROIraw <- ROI}
  
  midP <- ceiling(max(n_steps)/2)
  downHalf <- seq(1,midP,length.out = midP)
  upHalf <- seq(midP+1,max(n_steps),length.out = max(n_steps)-midP)
  
  if(is.null(type.to)){
    downHalf <- 1:max(n_steps)
    upHalf <- integer(0)
  }
  if(is.null(type.from)){
    downHalf <- integer(0)
    upHalf <- 1:max(n_steps)
  }
  
  knownConnections <- getTypeToTypeTable(getConnectionTable(character(0),"PRE"))
  knownUnknowns <- getMeta(character(0)) %>% mutate(previous.type=type)
  type.from_toAdd <- getMeta(character(0))
  
  for (n in downHalf){
    bag <- neuronBag(type.from,slctROI=ROIraw,by.roi=by.roi,omitInputs=TRUE,computeKnownRatio=computeKnownRatio,renaming=renaming,...)  
    if (is.list(ROI)){
      bag_list <- lapply(names(ROI),function(r) {combineRois(bag,ROI[[r]],r)})
      bag <- do.call(c,bag_list)
    }
    
    if(!is.null(thresholdPerROI)){bag$outputs <- filter(bag$outputs,knownTotalROIweight>thresholdPerROI & knownTotalPreROIweight>thresholdPerROI)}
    
    resLoc <- bag$outputs
    res[[n]] <- distinct(rbind(resLoc,filter(knownConnections,type.from %in% type.from_toAdd$type)))
    if (addContraPaths) res[[n]] <- addContraSide(res[[n]])
    
    outRef <- renaming(getTypesTable(unique(res[[n]]$databaseType.to)) %>% mutate(databaseType = type)) %>% filter(type %in% res[[n]]$type.to)
    unknowns <- retype.na_meta(getMeta(unique(bag$outputs_raw$to[!(bag$outputs_raw$to %in% outRef$bodyid)])) %>% mutate(previous.type=type))
    knownUnknowns <- distinct(rbind(unknowns,knownUnknowns))
    outRef <- distinct(filter(rbind(outRef,unknowns,knownUnknowns),type %in% res[[n]]$type.to))
    
    knownConnections <- distinct(rbind(knownConnections,resLoc))
    type.from_toAdd <- filter(outRef,type %in% unique(knownConnections$type.from))
    type.from <- filter(outRef,!(type %in% unique(knownConnections$type.from)))
  }
  
  knownConnectionsIn <- getTypeToTypeTable(getConnectionTable(NULL,"PRE"))
  type.to_toAdd <- getMeta(character(0))
  for (n in rev(upHalf)){
    bag <- neuronBag(type.to,slctROI=ROIraw,by.roi=by.roi,omitOutputs=TRUE,computeKnownRatio=computeKnownRatio,renaming=renaming,...)   
    if (is.list(ROI)){
      bag_list <- lapply(names(ROI),function(r) {combineRois(bag,ROI[[r]],r)})
      bag <- do.call(c,bag_list)
    }

    if(!is.null(thresholdPerROI)){bag$inputs <- filter(bag$inputs,knownTotalROIweight>thresholdPerROI & knownTotalPreROIweight>thresholdPerROI)}
    
    resLoc <- bag$inputs
    
    res[[n]] <- rbind(resLoc,filter(knownConnectionsIn,type.to %in% type.to_toAdd$type))
    if (addContraPaths) res[[n]] <- addContraSide(res[[n]])
    
    knownConnectionsIn <- distinct(rbind(knownConnectionsIn,resLoc))
    
    type.to <- renaming(getTypesTable(unique(res[[n]]$databaseType.from)) %>% mutate(databaseType=type)) %>% filter(type %in% res[[n]]$type.from)
    unknowns <- retype.na_meta(getMeta(unique(bag$inputs_raw$from[!(bag$inputs_raw$from %in% type.to$bodyid)])) %>% mutate(previous.type=type))
    knownUnknowns <- distinct(rbind(unknowns,knownUnknowns))
    type.to <- distinct(filter(rbind(type.to,unknowns,knownUnknowns),type %in% res[[n]]$type.from))
    
    type.to_toAdd <- filter(type.to,type %in% unique(knownConnectionsIn$type.to))
    type.to <- filter(type.to,!(type %in% unique(knownConnectionsIn$type.to)))
    
  }
  
  res
}

#' Multiply 2 connection tables or a pathway table and a connection table and return a type to type pathway table
#' @param inputTable  a type to type connection table, or a pathway table as returned by this function
#' @param outputTable a type to type connection table
#' @param stat which stat to use for pathway weights. Can be a vector. If NULL (the default), all the available meaningful stats are used: 
#' (\code{"weightRelative","outputContribution","knownWeightRelative","knownOutputContribution","knownOutputContribution_perType","knownWROutputContribution_perType","knownWeightRelative_perType"})
#' @param n a number to label the stage in processing 
#' @return a table with a stat_pathway extra column, and type and roi columns labeled with n or n+1 depending if they are 
#' at the first or second step of the pathway
#' @export
tables2path <- function(inputTable,outputTable,stat=NULL,n=1){
  if(is.null(stat)) stat <- c("weightRelative","outputContribution","knownWeightRelative","knownOutputContribution","knownOutputContribution_perType","knownWROutputContribution_perType","knownWeightRelative_perType")
  inputTable <-  select(inputTable,starts_with((c("type",
                                        "databaseType",
                                        "supertype",
                                        "roi",paste0(stat,"_")))) | any_of(stat))
  outputTable <-  select(outputTable,starts_with((c("type",
                                        "databaseType",
                                        "supertype",
                                        "roi",paste0(stat,"_")))) | any_of(stat))
 
 
  res <- inner_join(inputTable,outputTable,by=c("type.to"="type.from",
                                                "databaseType.to"="databaseType.from",
                                                "supertype1.to"="supertype1.from",
                                                "supertype2.to"="supertype2.from",
                                                "supertype3.to"="supertype3.from"
                                                ),suffix=c(paste0("_N",n),paste0("_N",n+1)))  %>% 
    rename(!!paste0("type_N",n) := "type.to",
           "type.to"=!!paste0("type.to_N",n+1),
           !!paste0("databaseType_N",n):="databaseType.to",
           "databaseType.to"=!!paste0("databaseType.to_N",n+1),
           !!paste0("supertype1_N",n):="supertype1.to",
           "supertype1.to"=!!paste0("supertype1.to_N",n+1),
           !!paste0("supertype2_N",n):="supertype2.to",
           "supertype2.to"=!!paste0("supertype2.to_N",n+1),
           !!paste0("supertype3_N",n):="supertype3.to",
           "supertype3.to"=!!paste0("supertype3.to_N",n+1)) %>% 
    rename_with(paste0,"_N",n+1,.cols = any_of(stat)) %>%
    rename_with(paste0,"_N",n+1,.cols = any_of("roi"))
  
  for (st in stat[paste0(stat,"_N",n) %in% names(res)]){
    if (!(paste0(st,"_path") %in% names(res))){
      res[[paste0(st,"_path")]] <- res[[paste0(st,"_N",n)]]
    }
    
    res[[paste0(st,"_path")]] <- res[[paste0(st,"_path")]] * res[[paste0(st,"_N",n+1)]]
  }
  res
}



#' Link an arbitrary number of connection tables into a pathway table
#' 
#' @param ... An arbitrary number of connection tables or a list of connection tables. In desired downstream order
#' @inheritParams get_type2typePath
#' @export
tableChain2path <- function(...,n_steps=NULL,stat=NULL,excludeLoops=TRUE,type.to=NULL){
  if(is.null(stat)) stat <- c("weightRelative","outputContribution","knownWeightRelative","knownOutputContribution","knownOutputContribution_perType","knownWROutputContribution_perType","knownWeightRelative_perType")
  res <- rlang::list2(...)
  if (length(res) == 1 && rlang::is_bare_list(res[[1]])) {
    res <- res[[1]]
  }
  if (is.null(n_steps)){n_steps <- seq(length(res))}
  res <- bind_rows(lapply(n_steps,function(nS){
    pathTable <- res[[1]]
    for (i in seq(2,nS,length.out = nS-1)){
      pathTable <- tables2path(pathTable,res[[i]],stat=stat,n=i-1)
    }
    if (!is.null(type.to)){
      pathTable <- pathTable[(pathTable$type.to %in% type.to$type),]
    }
    pathTable[["n_steps"]] <- nS
    if (nS == 1){
      pathTable <- pathTable %>% rename_with(paste0,"_N1",.cols = any_of(stat)) %>%
        rename_with(paste0,"_N1",.cols = any_of("roi")) %>%
        select(starts_with((c("type",
                              "databaseType",
                              "supertype",
                              "roi",paste0(stat,"_N1"),"n_steps"))))
      for (st in stat[paste0(stat,"_N1") %in% names(pathTable)]){
        pathTable[[paste0(st,"_path")]] <- pathTable[[paste0(st,"_N1")]]
      }
    }
    pathTable 
  }))
  
  res <- res %>% rowwise() %>% mutate(loop=any(duplicated(c_across(starts_with("type_") |
                                                                     starts_with("type.from")),
                                                          incomparables = c(NA,FALSE))) |
                                        any(duplicated(c_across(starts_with("type_") |
                                                                  starts_with("type.to")),
                                                       incomparables = c(NA,FALSE))
                                        ))
  if (excludeLoops) res  <- filter(res,loop==FALSE)
  res %>% select(type.from,
                 starts_with("type_"),
                 type.to,
                 starts_with("roi"),
                 starts_with(paste0(stat,"_N")),
                 starts_with(paste0(stat,"_path")),
                 n_steps,
                 loop,
                 starts_with("supertype"),
                 starts_with("databaseType"))
}


#' Functions to deal with crossing to the bad side of the brain
addContraSide <- function(connTable){
  rbind(connTable,simulatedContraSide(connTable))
}


simulatedContraSide <- function(connTable){
  simulated <- connTable %>% mutate(type.from=lrInvert(type.from),
                                    type.to=lrInvert(type.to),
                                    roi = paste0(roi,"_contra"))
  
  simulated <- filter(simulated,grepl("(R)",roi) | roi=="SAD_contra" | roi=="PRW_contra") ## Non lateralized neuropiles shouldn't be simulated
  
  simulated
  
}

lrInvert <- function(typeNames){
  toReplaceLeft <- grepl("_L$|_L[1-9]$|_L[1-9]/[1-9]$|_L[1-9]_C[1-9]$|_L[1-9]_C[1-9]_irreg$|_L_C[1-9]_irreg$|_L_small$",
                         typeNames)
  toReplaceRight <- grepl("_R$|_R[1-9]$|_R[1-9]/[1-9]$|_R[1-9]_C[1-9]$|_R[1-9]_C[1-9]_irreg$|_R_C[1-9]_irreg$|_R_small$",
                          typeNames)
  typeNames[toReplaceLeft] <- gsub("_L","_R",typeNames[toReplaceLeft])
  typeNames[toReplaceRight] <- gsub("_R","_L",typeNames[toReplaceRight])
  
  typeNames
}

#' Convert a type-to-type pathway dataframe to a graph dataframe
#' @param pathDf Dataframe generated by get_type2typePath()
#' @return Dataframe specifiying the graph resulting from combining the pathways in pathDF by listing all edges and their weights. Columns are
#' \code{to}, \code{from}, the statistic used as a weight in \code{pathDf} and supertypes to and from columns.
#' @export 
pathDf2graphDf <- function(pathDf){
 
  pathColNames <- colnames(pathDf)
  fromCols <- c("type.from",sort(pathColNames[grep("type_",pathColNames)]))
  toCols <- c(sort(pathColNames[grep("type_",pathColNames)]), "type.to")
  weightBaseName <- sub("_path","",pathColNames[grep("_path",pathColNames)])
  weights <- lapply(weightBaseName,function(wB) sort(pathColNames[grep(paste0(wB,"_N"),pathColNames)]))
  rois <- sort(pathColNames[grep("roi_",pathColNames)])
  
  
  for (i in seq(3)){
    assign( paste0("fromSupertype",i), c(paste0("supertype",i,".from"),sort(pathColNames[grep(paste0("supertype",i,"_N"),pathColNames)])))
    assign( paste0("toSupertype",i),  c(sort(pathColNames[grep(paste0("supertype",i,"_N"),pathColNames)]), paste0("supertype",i,".to")) )
  }
  
  graphDataFrame = data.frame(from = character(),
                              to = character())
  
  for(sN in seq(length(weightBaseName))){
    graphDataFrame[[weightBaseName[sN]]] <-  numeric()
  }
  for (step in seq(length(fromCols)) ){
    toNodes = pathDf[[toCols[step]]]
    toST1 = pathDf[[toSupertype1[step]]]
    toST2 = pathDf[[toSupertype2[step]]]
    toST3 = pathDf[[toSupertype3[step]]]
    
    nas = is.na(toNodes)
    toNodes[nas] = pathDf$type.to[nas]
    pathDf$type.to[nas] = NA
    
    
    
    toST1[nas] =pathDf$supertype1.to[nas]
    pathDf$supertype1.to[nas] = NA
    
    toST2[nas] = pathDf$supertype2.to[nas]
    pathDf$supertype2.to[nas] = NA
    
    toST3[nas] = pathDf$supertype3.to[nas]
    pathDf$supertype3.to[nas] = NA
    
    tmp = data.frame(from = pathDf[[fromCols[step]]],
                     to = toNodes,
                     supertype1.from = pathDf[[fromSupertype1[step]]],
                     supertype1.to = toST1,
                     supertype2.from = pathDf[[fromSupertype2[step]]],
                     supertype2.to = toST2,
                     supertype3.from = pathDf[[fromSupertype3[step]]],
                     supertype3.to = toST3)
    for(sN in seq(length(weightBaseName))){
      tmp[[weightBaseName[sN]]] <- pathDf[[weights[[sN]][step]]]
    }
    if(length(rois)>0){
      tmp$roi <- pathDf[[rois[step]]]
    }
    graphDataFrame = bind_rows(graphDataFrame,unique(tidyr::drop_na(tmp)))
  }
  
  return(graphDataFrame)
}