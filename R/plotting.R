#' Plot a hanesch type plot based on a summary of ROI innervation
#' @param roiTable A table of ROI innervation, as generated by \code{\link{getROISummary}}
#' @param roiSelect A selection of ROIs table, as generated by \code{\link{selectRoiSet}}
#' @param grouping A string of grouping variable(s) of \code{roiTable} to facet the plot on.
#' Will usually be one of the \code{supertype} columns
#' @param flip Flip the x/y axis? If TRUE, types will be on the bottom axis and ROIs on the
#' side axis
#' @param alphaRois The alpha of the color rectangles coding the ROIs
#' @param roiLabel A selection of ROIs, as generated by \code{\link{selectRoiSet}} to be used for the ROI color guide
#' @param regionOutlines Whether or not to add the ROI color code
#' @param theme Theme to be passed to ggplot2
#' @param interactive Whether or not to use some interactivity from ggiraph
#' @param showCount Whether or not to print the number of instances in the type in the tick labels
#'
#' @export
haneschPlot <- function(roiTable,
                        roiSelect=selectRoiSet(getRoiTree()),
                        grouping=NULL,flip=FALSE,
                        alphaRois=0.15,
                        roiLabel=selectRoiSet(getRoiTree(),default_level = 0),
                        regionOutlines=TRUE,
                        theme=theme_minimal(),
                        interactive=FALSE,
                        showCount=FALSE){
  roiTable <- roiTable %>% filter(roi %in% unique(roiSelect$roi))  %>%
    mutate(roi = factor(roi,levels=levels(roiSelect$roi)),
           l4 = roiSelect$level4[match(roi,roiSelect$roi)],
           side = roiSelect$side2[match(roi,roiSelect$roi)],
           superroi = roiLabel$roi[match(l4,roiLabel$level4)]) %>%
    arrange(roi) %>%
    mutate(roiX = match(roi,unique(roi)))

  roiPos <- roiTable %>% group_by(superroi,side) %>%
    summarize(xmin=min(roiX)-0.45,xmax=max(roiX)+0.45) %>%
    ungroup()

  if (showCount)
    roiTable <- mutate(roiTable,yV = paste0(type, " (n= ",n,")"))
  else
    roiTable <- mutate(roiTable,yV=type)

  hanesch <- ggplot(data=roiTable,aes(x=roi,y=yV))

  roiP <- roisPalette()

  if (interactive){
    hanesch <- hanesch + ggiraph::geom_line_interactive(aes(group=yV,data_id=type))
  }else{
    hanesch <- hanesch + geom_line(aes(group=yV))
  }
  if (regionOutlines==TRUE){hanesch <- hanesch +
    geom_rect(data=roiPos,aes(xmin=xmin,xmax=xmax,ymin=-Inf,ymax=Inf,fill=superroi),alpha=alphaRois,inherit.aes = F) +
    scale_fill_manual(name="Brain region",values=roiP,guide = guide_legend(reverse = TRUE)) +
    ggnewscale::new_scale_fill()}
  if (interactive){
    hanesch <- hanesch + ggiraph::geom_point_interactive(data=roiTable,
                                                         aes(size=fullWeight,
                                                             fill=deltaWeight,
                                                             x=roi,
                                                             y=yV,
                                                             tooltip=paste0(type," in ",roi,
                                                                            "\nOutputs: ",format(downstream,digits=2,scientific=FALSE),
                                                                            "\nInputs: ",format(upstream,digits=2,scientific=FALSE),
                                                                            "\nn: ",n),
                                                             data_id=type),shape=21)}
  else{
    hanesch <- hanesch +
      geom_point(data=roiTable,aes(size=fullWeight,fill=deltaWeight,x=roi,y=yV),shape=21)}
  hanesch <- hanesch +
    scale_fill_gradient(limits=c(-1,1),name="Polarity",breaks=c(-1,-0.5,0,0.5,1),labels=c("Receives inputs","","Mixed","","Sends outputs"),low = "white", high = "black",
                        space = "Lab") +
    guides(fill = guide_legend(override.aes = list(size=5))) +
    scale_size_area(name = "# Synapses") + labs(y="Neuron type",x="Neuropile") + theme

  if (!(is.null(grouping))){
    if (flip==TRUE){fct <- paste(". ~",grouping)}else{fct <- paste(grouping,"~ .")}
    hanesch <- hanesch + facet_grid(as.formula(fct),scale="free",space="free")
  }

  if (flip==TRUE){hanesch <- hanesch + coord_flip()}
  hanesch + theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust=0.5))

}


#'Plot a connectivity matrix
#'
#'@param connObj A connectivity object. Either a connectivity table, a matrix with \code{dimnames} Inputs and Outputs(as returned by \code{\link{connectivityMatrix}}) or a \code{\link{connectivityCluster}} object.
#'@param slctROIs For connectivity tables, you can specify a selection of ROIs
#'@param grouping Which variable to use. Will be ignored when \code{connObj} is a \code{\link{connectivityCluster}} (the decision has already been made while clustering)
#'@param value Which variable to use as a plotting value
#'@param xaxis Should inputs or outputs be on the x axis (will match the value to "inputs" or "outputs")
#'@param theme A theme to use
#'@param cmax Maximum fill value for the color scale
#'@param replaceIds When plotting neuron to neuron connections: if TRUE (and connObj is either a table or a connectivityCluster), replace the bodyids with their corresponding name. For matrices also accepts a vector of names
#'@param orderIn Optional ordering of the inputs (ignored and replaced by the clustering order if connObj is a connectivityCluster). 
#'@param orderOut Optional ordering of the outputs (ignored and replaced by the clustering order if connObj is a connectivityCluster).
#'@param showTable When both inputs and outputs have been used for a clustering, which connectivity table to show.
#'@export
plotConnectivity <- function(connObj,
                             slctROIs=NULL,
                             grouping=c("type","neuron","supertype1","supertype2","supertype3","databaseType"),
                             value="weightRelative",
                             xaxis=c("inputs","outputs"),
                             facetInputs=".",
                             facetOutputs=".",
                             theme=theme_minimal(),
                             cmax=NULL,
                             replaceIds=TRUE,
                             orderIn=NULL,
                             orderOut=NULL,
                             showTable="inputs"){
  UseMethod("plotConnectivity")
}

#'@export
plotConnectivity.data.frame <- function(connObj,
                                        slctROIs=NULL,
                                        grouping=c("type","neuron","supertype1","supertype2","supertype3","databaseType","cluster"),
                                        value="weightRelative",
                                        xaxis=c("inputs","outputs"),
                                        facetInputs=".",
                                        facetOutputs=".",
                                        theme=theme_minimal(),
                                        cmax=NULL,
                                        replaceIds=TRUE,
                                        orderIn=NULL,
                                        orderOut=NULL,
                                        showTable="inputs"){
  xaxis <- match.arg(xaxis)
  grouping <-match.arg(grouping)
  if(is.null(cmax)){cmax <- max(connObj[[value]])}
  if (grouping=="neuron") {grouping <- ""}else{
    grouping=paste0(grouping,".")}
  from <- paste0(grouping,"from")
  to <- paste0(grouping,"to")
  
  connObj$Inputs <- connObj[[from]]
  connObj$Outputs <- connObj[[to]]
  
  if (is.null(orderIn)){orderIn <- 1:length(unique(connObj$Inputs))}
  if (is.null(orderOut)){orderOut <- 1:length(unique(connObj$Outputs))}
  
  connObj$Inputs <- factor(connObj$Inputs,levels=unique(connObj$Inputs)[orderIn])
  connObj$Outputs <- factor(connObj$Outputs,levels=unique(connObj$Outputs)[orderOut])
  
  replacement <- NULL
  if(grouping=="" & replaceIds){
    replacement <- list("from"=connObj$name.from[match(levels(connObj$Inputs),connObj$from)],"to"=connObj$name.to[match(levels(connObj$Outputs),connObj$to)])
  }
  
  if (xaxis=="inputs"){
    xVar <- "Inputs"
    yVar <- "Outputs"
  }else{
    xVar <- "Outputs"
    yVar <- "Inputs"
  }
  p <- ggplot(connObj,aes(x=!!sym(xVar),y=!!sym(yVar),fill=!!(sym(value)))) + geom_tile()
  if (grouping=="" & replaceIds){
    p <- p + scale_x_discrete(labels=replacement[[ifelse(xaxis=="inputs","from","to")]])+
      scale_y_discrete(labels=replacement[[ifelse(xaxis=="inputs","to","from")]])
  }
  facetX <- ifelse(xaxis=="inputs",facetInputs,facetOutputs)
  facetY <- ifelse(xaxis=="inputs",facetOutputs,facetInputs)
  facetExpr <- paste0(facetY," ~ ",facetX)
  p <- p + facet_grid(as.formula(facetExpr),scale="free",space="free")
  
  p +
    scale_fill_gradient2(name=value,low="thistle", mid="blueviolet", high="black", 
                         midpoint =0.5*cmax, limits=c(0,cmax))  + theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust=0.5))
 
}

#'@export
plotConnectivity.matrix <- function(connObj,
                                    slctROIs=NULL,
                                    grouping=c("type","neuron","supertype1","supertype2","supertype3","databaseType"),
                                    value="weightRelative",
                                    xaxis=c("inputs","outputs"),
                                    facetInputs=".",
                                    facetOutputs=".",
                                    theme=theme_minimal(),
                                    cmax=NULL,
                                    replaceIds=NULL,
                                    orderIn=NULL,
                                    orderOut=NULL,
                                    showTable="inputs"){
  xaxis <- match.arg(xaxis)
  if(is.null(cmax)){cmax <- max(connObj)}
  connDf <- conn_mat2df(connObj,orderIn=orderIn,orderOut=orderOut)
  if (is.null(orderIn)){orderIn=1:length(dimnames(connObj)$Inputs)}
  if (is.null(orderOut)){orderOut=1:length(dimnames(connObj)$Outputs)}
  if (xaxis=="inputs"){
    xVar <- "Inputs"
    yVar <- "Outputs"
    orderX <- orderIn
    orderY <- orderOut
  }else{
    xVar <- "Outputs"
    yVar <- "Inputs"
    orderX <- orderOut
    orderY <- orderIn
  }
  p <- ggplot(connDf,aes(x=!!sym(xVar),y=!!sym(yVar),fill=value)) + geom_tile()
  if (!is.null(replaceIds)){
    p <- p + scale_x_discrete(labels=replaceIds[[ifelse(xaxis=="inputs","from","to")]][orderX])+
      scale_y_discrete(labels=replaceIds[[ifelse(xaxis=="inputs","to","from")]][orderY])
  }
  p +
    scale_fill_gradient2(low="thistle", mid="blueviolet", high="black", 
                         midpoint =0.5*cmax, limits=c(0,cmax))  + theme(axis.text.x = element_text(angle = 90,hjust = 1,vjust=0.5))+coord_fixed()
}

#'@export
plotConnectivity.connectivityCluster <- function(connObj,
                                                 slctROIs=NULL,
                                                 grouping=c("type","neuron","supertype1","supertype2","supertype3","databaseType"),
                                                 value="weightRelative",
                                                 xaxis=c("inputs","outputs"),
                                                 facetInputs=".",
                                                 facetOutputs=".",
                                                 theme=theme_minimal(),
                                                 cmax=NULL,
                                                 replaceIds=TRUE,
                                                 orderIn=NULL,
                                                 orderOut=NULL,
                                                 showTable="inputs"){
  showTable <- match.arg(showTable)
  xaxis <- match.arg(xaxis)
  grouping <- connObj$grouping
  
  if(is.null(connObj$inputsTable)){showTable <- "outputs"}
  if(is.null(connObj$outputsTable)){showTable <- "inputs"}
  
  if(showTable=="inputs"){connTa <- connObj$inputsTable}else{connTa <- connObj$outputsTable}
  
  if(showTable=="inputs"){orderOut <- connObj$hc$order
                }else{
    orderIn <- connObj$hc$order
  }
  
  plotConnectivity(connTa,grouping=grouping,replaceIds=replaceIds,facetInputs=facetInputs,facetOutputs=facetOutputs,orderIn=orderIn,orderOut=orderOut,xaxis=xaxis,cmax=cmax,theme=theme)
}
