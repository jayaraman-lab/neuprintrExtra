#' Builds a data frame of pathways between 2 collections of types
#' @param type.from  a metadata data.frame for a set of neurons (typically generated by a search or a getTypesTable call) to start from
#' @param type.to  a metadata data.frame for a set of neurons (typically generated by a search or a getTypesTable call) to arrive to
#' @param by.roi return results by ROI or just global weights?
#' @param ROI which ROIs to consider. Can be a vector of ROI names, a list of vectors of ROI names, or NULL. If NULL (the default), consider all ROIs. 
#' If a character vector, restrict to those ROIs. If a list, each element of the list will be ROI that will be combined together (and named as the element name in the list) using combineRois
#' @param n_step an integer or vector of integers. If a vector paths of all those lenghts will be listed
#' @param renaming a renaming function to use (by default \code{cxRetyping})
#' @param stat the stat to consider (by default "weightRelative")
#' @param ... : to be passed to create_neuronBag when building the path
#' @export
get_type2typePath <- function(type.from,type.to,by.roi=TRUE,ROI=NULL,n_steps=2,renaming=cxRetyping,stat="weightRelative",...){
  res <- vector("list",max(n_steps))
  
  if (!("databaseType" %in% names(type.from))){type.from <- mutate(type.from,databaseType=type)}
  if (!("databaseType" %in% names(type.to))){type.to <- mutate(type.to,databaseType=type)}
  type.from <- renaming(type.from)
  type.to <- renaming(type.to)
  type.from_loc <- type.from
  type.to_loc <- type.to
  if (is.list(ROI)){ROIraw <- unlist(ROI,use.names = FALSE)}else{ROIraw <- ROI}
  
  for (n in 1:ceiling(max(n_steps)/2)){
    bag <- create_neuronBag(type.from_loc,slctROI=ROIraw,by.roi=by.roi,omitInputs=TRUE,selfRef=TRUE,...)  
    if (is.list(ROI)){
      bag_list <- lapply(names(ROI),function(r) {combineRois(bag,ROI[[r]],r)})
      bag <- do.call(c,bag_list)
    }
    bag <- renaming(bag)
    type.from_loc <- bag$outputsTableRef
    res[[n]] <- bag$outputs
  }
  for (n in (ceiling(max(n_steps)/2)+1):max(n_steps)){
    bag <- create_neuronBag(type.to_loc,slctROI=ROIraw,by.roi=by.roi,omitOutputs=TRUE,selfRef=TRUE,...)   
    if (is.list(ROI)){
      bag_list <- lapply(names(ROI),function(r) {combineRois(bag,ROI[[r]],r)})
      bag <- do.call(c,bag_list)
    }
    bag <- renaming(bag)
    type.to_loc <- getTypesTable(unique(bag$inputs_raw$databaseType.from)) %>% mutate(databaseType=type)
    unknowns <- retype.na_meta(neuprint_get_meta(unique(bag$inputs_raw$from[!(bag$inputs_raw$from %in% type.to_loc$bodyid)]))) %>% mutate(databaseType=NA)
    if (length(unknowns != 0)){type.to_loc <- bind_rows(type.to_loc,unknowns)}
    
    type.to_loc <- renaming(type.to_loc)
    type.to_loc <- filter(type.to_loc,type %in% bag$inputs$type.from)
    res[[n]] <- bag$inputs
  }
  
  bind_rows(lapply(n_steps,function(nS){
    pathTable <- res[[1]]
    for (i in 2:nS){
      pathTable <- tables2path(pathTable,res[[i]],stat=stat,n=i-1)
    }
    pathTable <- pathTable[(pathTable$type.to %in% type.to$type),]
  }))
  
}

#' Multiply 2 connection tables or a pathway table and a connection table and return a type to type pathway table
#' @param inputTable  a type to type connection table, or a pathway table as returned by this function
#' @param outputTable a type to type connection table
#' @param stat which stat to use for pathway weights
#' @param n a number to label the stage in processing 
#' @return a table with a stat_pathway extra column, and type and roi columns labeled with n or n+1 depending if they are 
#' at the first or second step of the pathway
#' @export
tables2path <- function(inputTable,outputTable,stat="weightRelative",n=1){
  inputTable <-  select(inputTable,starts_with((c("type",
                                        "databaseType",
                                        "supertype",
                                        "roi",paste0(stat,"_")))) | any_of(stat))
  outputTable <-  select(outputTable,starts_with((c("type",
                                        "databaseType",
                                        "supertype",
                                        "roi",paste0(stat,"_")))) | any_of(stat))
 
 
  res <- inner_join(inputTable,outputTable,by=c("type.to"="type.from",
                                                "databaseType.to"="databaseType.from",
                                                "supertype.to1"="supertype.from1",
                                                "supertype.to2"="supertype.from2",
                                                "supertype.to3"="supertype.from3"
                                                ),suffix=c(paste0("_N",n),paste0("_N",n+1)))  %>% 
    rename(!!paste0("type_N",n) := "type.to",
           "type.to"=!!paste0("type.to_N",n+1),
           !!paste0("databaseType_N",n):="databaseType.to",
           "databaseType.to"=!!paste0("databaseType.to_N",n+1),
           !!paste0("supertype1_N",n):="supertype.to1",
           "supertype.to1"=!!paste0("supertype.to1_N",n+1),
           !!paste0("supertype2_N",n):="supertype.to2",
           "supertype.to2"=!!paste0("supertype.to2_N",n+1),
           !!paste0("supertype3_N",n):="supertype.to3",
           "supertype.to3"=!!paste0("supertype.to3_N",n+1)) %>% 
    rename_with(paste0,"_N",n+1,.cols = any_of(stat)) %>%
    rename_with(paste0,"_N",n+1,.cols = any_of("roi"))
  
  if (!(paste0(stat,"_path") %in% names(res))){
    res[[paste0(stat,"_path")]] <- res[[paste0(stat,"_N",n)]]
  }
  
  res[[paste0(stat,"_path")]] <- res[[paste0(stat,"_path")]] * res[[paste0(stat,"_N",n+1)]]
  res
}