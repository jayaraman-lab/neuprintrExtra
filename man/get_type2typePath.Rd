% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/typesPathways.R
\name{get_type2typePath}
\alias{get_type2typePath}
\alias{get_type2typePath_raw}
\title{Builds a data frame of pathways between 2 collections of types
\code{get_type2typePath} returns a pathway table, whereas \code{get_type2typePath_raw} returns a list of connection tables}
\usage{
get_type2typePath(
  type.from = NULL,
  type.to = NULL,
  by.roi = TRUE,
  ROI = NULL,
  n_steps = 2,
  renaming = NULL,
  stat = NULL,
  excludeLoops = TRUE,
  addContraPaths = FALSE,
  thresholdPerROI = NULL,
  computeKnownRatio = FALSE,
  chunkPath = FALSE,
  addRecursive = FALSE,
  overruleThreshold = Inf,
  ...
)

get_type2typePath_raw(
  type.from = NULL,
  type.to = NULL,
  by.roi = TRUE,
  ROI = NULL,
  n_steps = 2,
  renaming = NULL,
  addContraPaths = FALSE,
  thresholdPerROI = NULL,
  computeKnownRatio = FALSE,
  overruleThreshold = Inf,
  ...
)
}
\arguments{
\item{type.from}{a metadata data.frame for a set of neurons (typically generated by a search or a getTypesTable call) to start from}

\item{type.to}{a metadata data.frame for a set of neurons (typically generated by a search or a getTypesTable call) to arrive to}

\item{by.roi}{return results by ROI or just global weights?}

\item{ROI}{which ROIs to consider. Can be a vector of ROI names, a list of vectors of ROI names, or NULL. If NULL (the default), consider all ROIs. 
If a character vector, restrict to those ROIs. If a list, each element of the list will be ROI that will be combined together 
(and named as the element name in the list) using combineRois}

\item{renaming}{a renaming function to use (by default \code{cxRetyping})}

\item{stat}{which stat to use for pathway weights. Can be a vector. If NULL (the default), all the available meaningful stats are used: 
(\code{"weightRelative","outputContribution","knownWeightRelative","knownOutputContribution","knownOutputContribution_perType","knownWROutputContribution_perType","knownWeightRelative_perType"})}

\item{excludeLoops}{Logical, whether to exclude paths containing duplicates (TRUE by default)}

\item{addContraPaths}{Experimental: simulate the opposite side of the brain assuming symetry. The new ROI will be called roi_contra. Only ROIs containing "(R)" 
in their name will be considered}

\item{thresholdPerROI}{Optional filtering of the connection tables to limit to types containing at least \code{thresholdPerROI} synapses of the right 
polarity in the ROI considered}

\item{computeKnownRatio}{Compute total relative metrics at each step (this is slow)}

\item{chunkPath}{Chunking argument to be passed to the function chaining the connection tables together. Useful for deep pathways. Can either be logical,
or an integer specifying the number of connections in the starting table to process at once.}

\item{addRecursive}{Whether or not to add the recursive paths (of length greater than \code{n_steps}) present in the connection tables generated.}

\item{...}{: to be passed to neuronBag when building the path}

\item{n_step}{an integer or vector of integers. If a vector paths of all those lenghts will be listed.}
}
\description{
Builds a data frame of pathways between 2 collections of types
\code{get_type2typePath} returns a pathway table, whereas \code{get_type2typePath_raw} returns a list of connection tables
}
\details{
\itemize{
\item If n_steps is 3, only paths of length 3 will be listed. To get all paths of length 1 to 3, you need to pass 1:3 to n_steps. 
All vectors of integers are possible for n_steps.
\item If \code{type.from} or \code{type.to} are left unspecified, all pathways of the specified length to (resp. from) the specified type are listed.
Use at your own risk, as this can potentially result in very large objects.
}
}
\section{Functions}{
\itemize{
\item \code{get_type2typePath_raw}: Returns the list of connection tables (can be chained with tableChain2path)
}}

