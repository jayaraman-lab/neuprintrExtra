#' Builds a data frame of pathways between 2 collections of types
#' @param type.from  a metadata data.frame for a set of neurons (typically generated by a search or a getTypesTable call) to start from
#' @param type.to  a metadata data.frame for a set of neurons (typically generated by a search or a getTypesTable call) to arrive to
#' @param by.roi return results by ROI or just global weights?
#' @param ROI which ROIs to consider. Can be a vector of ROI names, a list of vectors of ROI names, or NULL. If NULL (the default), consider all ROIs. 
#' If a character vector, restrict to those ROIs. If a list, each element of the list will be ROI that will be combined together (and named as the element name in the list) using combineRois
#' @param n_step an integer or vector of integers. If a vector paths of all those lenghts will be listed
#' @param renaming a renaming function to use (by default \code{cxRetyping})
#' @param stat the stat to consider (by default "weightRelative")
#' @param excludeLoops Logical, whether to exclude paths containing duplicates (TRUE by default)
#' @param ... : to be passed to neuronBag when building the path
#' @export
get_type2typePath <- function(type.from,
                              type.to,
                              by.roi=TRUE,
                              ROI=NULL,
                              n_steps=2,
                              renaming=cxRetyping,
                              stat="weightRelative",
                              excludeLoops=TRUE,
                              ...){
  res <- vector("list",max(n_steps))
  
  if (!("databaseType" %in% names(type.from))){type.from <- mutate(type.from,databaseType=type)}
  if (!("databaseType" %in% names(type.to))){type.to <- mutate(type.to,databaseType=type)}
  type.from <- renaming(type.from)
  type.to <- renaming(type.to)
  type.from_loc <- type.from
  type.to_loc <- type.to
  if (is.list(ROI)){ROIraw <- unlist(ROI,use.names = FALSE)}else{ROIraw <- ROI}
  
  midP <- ceiling(max(n_steps)/2)
  downHalf <- seq(1,midP,length.out = midP)
  upHalf <- seq(midP+1,max(n_steps),length.out = max(n_steps)-midP)
  
  for (n in downHalf){
    bag <- neuronBag(type.from_loc,slctROI=ROIraw,by.roi=by.roi,omitInputs=TRUE,selfRef=TRUE,...)  
    if (is.list(ROI)){
      bag_list <- lapply(names(ROI),function(r) {combineRois(bag,ROI[[r]],r)})
      bag <- do.call(c,bag_list)
    }
    bag <- renaming(bag)
    type.from_loc <- bag$outputsTableRef
    res[[n]] <- bag$outputs
  }
  for (n in rev(upHalf)){
    bag <- neuronBag(type.to_loc,slctROI=ROIraw,by.roi=by.roi,omitOutputs=TRUE,selfRef=TRUE,...)   
    if (is.list(ROI)){
      bag_list <- lapply(names(ROI),function(r) {combineRois(bag,ROI[[r]],r)})
      bag <- do.call(c,bag_list)
    }
    bag <- renaming(bag)
    type.to_loc <- getTypesTable(unique(bag$inputs_raw$databaseType.from)) %>% mutate(databaseType=type)
    unknowns <- retype.na_meta(neuprint_get_meta(unique(bag$inputs_raw$from[!(bag$inputs_raw$from %in% type.to_loc$bodyid)]))) %>% mutate(databaseType=NA)
    if (length(unknowns != 0)){type.to_loc <- bind_rows(type.to_loc,unknowns)}
    
    type.to_loc <- renaming(type.to_loc)
    type.to_loc <- filter(type.to_loc,type %in% bag$inputs$type.from)
    res[[n]] <- bag$inputs
  }
  
  res <- bind_rows(lapply(n_steps,function(nS){
    pathTable <- res[[1]]
    for (i in seq(2,nS,length.out = nS-1)){
      pathTable <- tables2path(pathTable,res[[i]],stat=stat,n=i-1)
    }
    pathTable <- pathTable[(pathTable$type.to %in% type.to$type),]
    pathTable[["n_steps"]] <- nS
    if (nS == 1){
    pathTable <- pathTable %>% rename_with(paste0,"_N1",.cols = any_of(stat)) %>%
      rename_with(paste0,"_N1",.cols = any_of("roi")) %>%
      select(starts_with((c("type",
                            "databaseType",
                            "supertype",
                            "roi",paste0(stat,"_N1"),"n_steps"))))
    pathTable[[paste0(stat,"_path")]] <- pathTable[[paste0(stat,"_N1")]]
    }
    pathTable 
  }))
  ## Test for loops, considering the special case where the user ask for pathways
  ## to self
  res <- res %>% rowwise() %>% mutate(loop=any(duplicated(c_across(starts_with("type_") |
                                                       starts_with("type.from")),
                                                       incomparables = c(NA,FALSE))) |
                                        any(duplicated(c_across(starts_with("type_") |
                                                                  starts_with("type.to")),
                                                       incomparables = c(NA,FALSE))
                                        ))
  if (excludeLoops) res  <- filter(res,loop==FALSE)
  res %>% select(type.from,
                 starts_with("type_"),
                 type.to,
                 starts_with("roi"),
                 starts_with(paste0(stat,"_N")),
                 starts_with(paste0(stat,"_path")),
                 n_steps,
                 loop,
                 starts_with("supertype"),
                 starts_with("databaseType"))
}

#' Multiply 2 connection tables or a pathway table and a connection table and return a type to type pathway table
#' @param inputTable  a type to type connection table, or a pathway table as returned by this function
#' @param outputTable a type to type connection table
#' @param stat which stat to use for pathway weights
#' @param n a number to label the stage in processing 
#' @return a table with a stat_pathway extra column, and type and roi columns labeled with n or n+1 depending if they are 
#' at the first or second step of the pathway
#' @export
tables2path <- function(inputTable,outputTable,stat="weightRelative",n=1){
  inputTable <-  select(inputTable,starts_with((c("type",
                                        "databaseType",
                                        "supertype",
                                        "roi",paste0(stat,"_")))) | any_of(stat))
  outputTable <-  select(outputTable,starts_with((c("type",
                                        "databaseType",
                                        "supertype",
                                        "roi",paste0(stat,"_")))) | any_of(stat))
 
 
  res <- inner_join(inputTable,outputTable,by=c("type.to"="type.from",
                                                "databaseType.to"="databaseType.from",
                                                "supertype1.to"="supertype1.from",
                                                "supertype2.to"="supertype2.from",
                                                "supertype3.to"="supertype3.from"
                                                ),suffix=c(paste0("_N",n),paste0("_N",n+1)))  %>% 
    rename(!!paste0("type_N",n) := "type.to",
           "type.to"=!!paste0("type.to_N",n+1),
           !!paste0("databaseType_N",n):="databaseType.to",
           "databaseType.to"=!!paste0("databaseType.to_N",n+1),
           !!paste0("supertype1_N",n):="supertype1.to",
           "supertype1.to"=!!paste0("supertype1.to_N",n+1),
           !!paste0("supertype2_N",n):="supertype2.to",
           "supertype2.to"=!!paste0("supertype2.to_N",n+1),
           !!paste0("supertype3_N",n):="supertype3.to",
           "supertype3.to"=!!paste0("supertype3.to_N",n+1)) %>% 
    rename_with(paste0,"_N",n+1,.cols = any_of(stat)) %>%
    rename_with(paste0,"_N",n+1,.cols = any_of("roi"))
  
  if (!(paste0(stat,"_path") %in% names(res))){
    res[[paste0(stat,"_path")]] <- res[[paste0(stat,"_N",n)]]
  }
  
  res[[paste0(stat,"_path")]] <- res[[paste0(stat,"_path")]] * res[[paste0(stat,"_N",n+1)]]
  res
}


#' Convert a type-to-type pathway dataframe to a graph dataframe
#' @param pathDf Dataframe generated by get_type2typePath()
#' @return Dataframe specifiying the graph resulting from combining the pathways in pathDF by listing all edges and their weights. Columns are
#' \code{to}, \code{from}, the statistic used as a weight in \code{pathDf} and supertypes to and from columns.
#' @export 
pathDf2graphDf <- function(pathDf){
 
  pathColNames <- colnames(pathDf)
  fromCols <- c("type.from",sort(pathColNames[grep("type_",pathColNames)]))
  toCols <- c(sort(pathColNames[grep("type_",pathColNames)]), "type.to")
  weightBaseName <- sub("_path","",pathColNames[grep("_path",pathColNames)])
  weights <- sort(pathColNames[grep(paste0(weightBaseName,"_N"),pathColNames)])
  
  
  for (i in seq(3)){
    assign( paste0("fromSupertype",i), c(paste0("supertype",i,".from"),pathColNames[grep(paste0("supertype",i,"_N"),pathColNames)]) )
    assign( paste0("toSupertype",i),  c(pathColNames[grep(paste0("supertype",i,"_N"),pathColNames)], paste0("supertype",i,".to")) )
  }
  
  graphDataFrame = data.frame(from = character(),
                              to = character())
  
  graphDataFrame[[weightBaseName]] <-  numeric()
  
  for (step in seq(length(fromCols)) ){
    toNodes = pathDf[[toCols[step]]]
    toST1 = pathDf[[toSupertype1[step]]]
    toST2 = pathDf[[toSupertype2[step]]]
    toST3 = pathDf[[toSupertype3[step]]]
    
    nas = is.na(toNodes)
    toNodes[nas] = pathDf$type.to[nas]
    pathDf$type.to[nas] = NA
    
    toST1[nas] =pathDf$supertype1.to[nas]
    pathDf$supertype1.to[nas] = NA
    
    toST2[nas] = pathDf$supertype2.to[nas]
    pathDf$supertype2.to[nas] = NA
    
    toST3[nas] = pathDf$supertype3.to[nas]
    pathDf$supertype3.to[nas] = NA
    
    tmp = data.frame(from = pathDf[[fromCols[step]]],
                     to = toNodes,
                     supertype1.from = pathDf[[fromSupertype1[step]]],
                     supertype1.to = toST1,
                     supertype2.from = pathDf[[fromSupertype2[step]]],
                     supertype2.to = toST2,
                     supertype3.from = pathDf[[fromSupertype3[step]]],
                     supertype3.to = toST3)
    tmp[[weightBaseName]] <- pathDf[[weights[step]]]
    graphDataFrame = bind_rows(graphDataFrame,unique(tidyr::drop_na(tmp)))
  }
  
  return(graphDataFrame)
}